subset = !duplicated(tempSubset[c("coverage")]),
select = c("chrom", "start", "stop","coverage","strand"))
OMF$HighestPeak[peakFrameCoord] <- tempSubset$stop[1]
OMF$HighestPeakReadCoverage[peakFrameCoord] <-tempSubset$coverage[1]
OMF$LowestPeakCoord[peakFrameCoord] <- min(TPH$stop)
OMF$HighestPeakCoord[peakFrameCoord] <- max(TPH$stop)
peakFrameCoord <- peakFrameCoord + 1
OMF[peakFrameCoord,] <- NA
TPH <- as.data.frame(matrix(nrow = 0, ncol = ncol(outputFrame)))
colnames(TPH) <- colnames(outputFrame)
}
}
#Remove any NA's that pop up
OMF_Top <- OMF[complete.cases(OMF),]
rownames(OMF_Top) <- 1:nrow(OMF_Top)
OMF_Top$LowestPeakCoord <- as.numeric(OMF_Top$LowestPeakCoord)
OMF_Top$HighestPeakCoord <- as.numeric(OMF_Top$HighestPeakCoord)
OMF_Top$HighestPeakReadCoverage <- as.numeric(OMF_Top$HighestPeakReadCoverage)
OMF_Top$HighestPeak <- as.numeric(OMF_Top$HighestPeak)
return(OMF_Top)
}
#' @importFrom dplyr arrange distinct
#' @importFrom stats aggregate ppois complete.cases
#' @importFrom utils write.csv write.table read.table read.delim
#' @param TopInititalCondense Uses the output of TopStrand_InitialCondense as the input
#' @param peakCondensingDistance peakCondensingDistance Following the initial peak condensing step, this parameter is used to identify peak structures in the data that are close enough to be considered part of the same termination signal. In testing, we have not identified cases in which two distinct termination signals so proximal that the default parameters incorrectly combine the signals together.
#' @param OutputFileName A string that will be used to identify printed results files. When run with PIPETS_FullRun, this string will be input by the user in the beginning
#' @return The method writes a csv file in the project directory that contains the results for the Top Strand termination peaks
#' @export
#'
#'
TopStrand_SecondaryCondense <- function(TopInititalCondense,
peakCondensingDistance = 20,
OutputFileName){
OMF_Top <- TopInititalCondense
TWH <- as.data.frame(matrix(nrow = 0, ncol = ncol(OMF_Top)))
colnames(TWH) <- colnames(OMF_Top)
#This data frame is the output of the file.
SWR_Top <- as.data.frame(matrix(nrow = 1, ncol = 6))
colnames(SWR_Top) <- c("chrom","strand","HighestPeak",
"HighestPeakReadCoverage","LowestPeakCoord","HighestPeakCoord")
#Parameters for the merging for loop below
x <- 1
PFC <- 1
#This loop condenses proximal peaks instead of proximal positions
for(x in seq_along(OMF_Top[,1])){
tempSubset <- ""
#This is the basic condition
if(x < nrow(OMF_Top) & (OMF_Top$LowestPeakCoord[x+1] - OMF_Top$HighestPeakCoord[x]) <= peakCondensingDistance ){
TWH <- rbind(TWH,OMF_Top[x,])
}
#This statement handles the final position
else if(x == nrow(OMF_Top)){
#If the final position is in the same peak as the previous position
if((OMF_Top$HighestPeakCoord[x] - OMF_Top$LowestPeakCoord[(x-1)]) <= peakCondensingDistance) {
TWH <- rbind(TWH,OMF_Top[x,])
SWR_Top$chrom[PFC] <- OMF_Top$chrom[1]
SWR_Top$strand[PFC] <- OMF_Top$strand[1]
tempSubset <- subset(TWH,
"HighestPeakReadCoverage" == max(TWH$HighestPeakReadCoverage))
tempSubset <- subset(tempSubset,subset = !duplicated(tempSubset[c("HighestPeakReadCoverage")]),select = c("chrom","strand","HighestPeak","HighestPeakReadCoverage","LowestPeakCoord","HighestPeakCoord"))
SWR_Top$HighestPeak[PFC] <- tempSubset$HighestPeak[1]
SWR_Top$HighestPeakReadCoverage[PFC] <-
tempSubset$HighestPeakReadCoverage[1]
SWR_Top$LowestPeakCoord[PFC] <- min(TWH$LowestPeakCoord)
SWR_Top$HighestPeakCoord[PFC] <- max(TWH$HighestPeakCoord)
PFC <- PFC + 1
SWR_Top[PFC,] <- NA
TWH <- as.data.frame(matrix(nrow = 0, ncol = ncol(OMF_Top)))
colnames(TWH) <- colnames(OMF_Top)
}
#If the final WindowTest_TopStrandPeaks position is on its own
else if(!(OMF_Top$LowestPeakCoord[x] - OMF_Top$HighestPeakCoord[x-1]) <= peakCondensingDistance){
SWR_Top[PFC,] <- c(OMF_Top$chrom[1],
OMF_Top$strand[x],
OMF_Top$HighestPeak[x],
OMF_Top$HighestPeakReadCoverage[x],
OMF_Top$HighestPeak[x],
OMF_Top$HighestPeak[x])
}
}
#This handles X+1$stop is not part of the same merged peak.
else {
TWH <- rbind(TWH,OMF_Top[x,])
SWR_Top$chrom[PFC] <- OMF_Top$chrom[1]
SWR_Top$strand[PFC] <- OMF_Top$strand[1]
tempSubset <- subset(TWH, "HighestPeakReadCoverage" == max(TWH$HighestPeakReadCoverage))
tempSubset <- subset(tempSubset, subset = !duplicated(tempSubset[c("HighestPeakReadCoverage")]),select = c("chrom","strand","HighestPeak","HighestPeakReadCoverage","LowestPeakCoord","HighestPeakCoord"))
SWR_Top$HighestPeak[PFC] <- tempSubset$HighestPeak[1]
SWR_Top$HighestPeakReadCoverage[PFC] <-
tempSubset$HighestPeakReadCoverage[1]
SWR_Top$LowestPeakCoord[PFC] <- min(TWH$LowestPeakCoord)
SWR_Top$HighestPeakCoord[PFC] <- max(TWH$HighestPeakCoord)
PFC <- PFC + 1
SWR_Top[PFC,] <- NA
TWH <- as.data.frame(matrix(nrow = 0, ncol = ncol(OMF_Top)))
colnames(TWH) <- colnames(OMF_Top)
}
}
SWR_Top <- SWR_Top[complete.cases(SWR_Top),]
write.csv(SWR_Top, file = paste(as.character(OutputFileName),"topStrandResults.csv", sep = "_"),  row.names = FALSE)
}
#' @return Returns a dataframe with all genomic positions that were identified as having significant read coverage.
#' @export
#'
#'
CompStrand_InitialPoisson <- function(PlusStrandReads,slidingWindowSize = 25,
slidingWindowMovementDistance = 25,
threshAdjust = 0.75,
pValue = 0.005,
topEndPercentage= 0.01){
SWMD <- slidingWindowMovementDistance
SWS <- slidingWindowSize
PSR <- PlusStrandReads
outputFrame <- as.data.frame(matrix(nrow = 0, ncol = 5))
colnames(outputFrame) <- colnames(PSR)
SWF <- as.data.frame(matrix(nrow = PSR[nrow(PSR),"start"], ncol = 2))
colnames(SWF) <- c("position","coverage")
SWF$coverage <- 0
SWF$position <- 1:nrow(SWF)
#Calculate a global threshold based on the data
threshCalc <- PSR$coverage[order(PSR$coverage, decreasing = TRUE)]
tempMax <- sum(threshCalc) * threshAdjust
posCount <- 1
breakCond <- 1
for(x in seq_along(threshCalc)){
tempMax <- tempMax - threshCalc[[x]]
if(tempMax > 0){
posCount <- posCount + 1
}
else if (tempMax <= 0 ){
posCount <- posCount - 1
break()
}
}
#Identify the top X% read coverage positions from posCount
rmTopEnd <- round(posCount * topEndPercentage)
#Final Global Theshold Creation
compThreshold <- sum(threshCalc[rmTopEnd:posCount])/(posCount - rmTopEnd)
#Prints the threshold for the top strand that will be used
message(paste("Complement Strand Cutoff", compThreshold, sep = " "))
#Assignes all coverages and fill in empty positions with 0
nm <- "coverage"
SWF[nm] <- lapply(nm, function(x) PSR[[x]][match(SWF$position, PSR$start)])
SWF$coverage[is.na(SWF$coverage)] <- 0
#initializes the parameters for the sliding window Poisson Testing
z <- 1+ slidingWindowSize
breakCond <- 0
numericBreakCond <- 0
#While loop to ensure that sliding window doesnt extend into nothing
while(breakCond == 0){
sumOfWindowCoverage <- sum(SWF$coverage[(z-slidingWindowSize):(z+slidingWindowSize)])
AOW <- sumOfWindowCoverage/((2*slidingWindowSize)+1)
for(y in (z-slidingWindowSize):(z+slidingWindowSize)){
if(SWF$coverage[y] >= 10){
#For each position in the window, run a poisson distribution hypothesis test to see if the read coverage exceeds the expected average read coverage for the window
probabilityAtY <- (1- ppois(q = SWF$coverage[y], lambda = AOW))
#Then check if the read coverage is greater than a global count threshold, if it has a higher coverage than 5* the window average, if it is signficiant in the test, and if the coverage is greater than 4
#All of these cutoffs and parameters were taken from the original 3pMap method
if(SWF$coverage[y] >= compThreshold & probabilityAtY <= pValue){
#If the criteria are met then the peak position is added to the outputFrame
outputFrame <- rbind(PSR[PSR$start == SWF$position[y],], outputFrame)
}
}
}
#This check is placed after the for loop so that the final round of checking can occur before the loop is broken
if(numericBreakCond == 1){
breakCond <- 1
}
#Checks if the sliding window has reached the point where if it continued forward, it would move past the end. Sets the break condition such that one final sliding window check can occur
if(numericBreakCond == 0 & (z+SWMD) >= (nrow(SWF)-slidingWindowSize)){
z <- (nrow(SWF)-slidingWindowSize)
numericBreakCond <- 1
}
#If the sliding window hasn't reached the end, simply iterates on z so that the sliding window can move
if(numericBreakCond == 0 & (z+SWMD) < (nrow(SWF)-slidingWindowSize)){
z <- (z + SWMD)
}
}
outputFrame <- outputFrame[!duplicated(outputFrame),]
outputFrame <- outputFrame[order(outputFrame$stop),]
rownames(outputFrame) <- 1:nrow(outputFrame)
return(outputFrame)
}
#' Takes the significant top strand positions from CompStrand_InitialPoisson and condenses all proximal positions into termination "peaks"
#' @importFrom dplyr arrange distinct
#' @importFrom stats aggregate ppois complete.cases
#' @importFrom utils write.csv write.table read.table read.delim
#' @param CompInitialPoisson Uses the output of CompStrand_InitialPoisson as the input
#' @param adjacentPeakDistance adjacentPeakDistance During the peak condensing step, this parameter is used to define “adjacent” for significant genomic positions. This is used to identify initial peak structures in the data. By default this value is set to 2 to ensure that single instances of loss of signal are not sufficient to prevent otherwise contiguous peak signatures from being combined.
#' @return Returns a dataframe that contains the list of termination "peaks" for the complement strand
#' @export
#'
#'
CompStrand_InitialCondense <- function(CompInitialPoisson,
adjacentPeakDistance = 2){
outputFrame <- CompInitialPoisson
#This object holds all the peak info for all positions that are within 2 bp
tempPeakHold <- as.data.frame(matrix(nrow = 0, ncol = ncol(outputFrame)))
colnames(tempPeakHold) <- colnames(outputFrame)
#This data frame is the output
OMF <- as.data.frame(matrix(nrow = 1, ncol = 6))
colnames(OMF) <- c("chrom","strand","HighestPeak",
"HighestPeakReadCoverage",
"LowestPeakCoord","HighestPeakCoord")
#Parameters for the merging for loop below
x <- 1
peakFrameCoord <- 1
#Consecutive check frame. Has some corner conditions that are specified
for(x in seq_along(outputFrame[,1])){
tempSubset <- ""
#If X$start is no more than 2 nucleotides away from X+1 at start
if(x < nrow(outputFrame) & (outputFrame$start[x+1] - outputFrame$start[x]) <= adjacentPeakDistance ){
tempPeakHold <- rbind(tempPeakHold,outputFrame[x,])
}
#This handles the final position of the outputFrame.
else if(x == nrow(outputFrame)){
#If final position is part of the same peak as the previous position
if((outputFrame$start[x] - outputFrame$start[(x-1)]) <= adjacentPeakDistance) {
tempPeakHold <- rbind(tempPeakHold,outputFrame[x,])
OMF$chrom[peakFrameCoord] <- outputFrame$chrom[1]
OMF$strand[peakFrameCoord] <- outputFrame$strand[1]
tempSubset <- subset(tempPeakHold, "coverage" == max(tempPeakHold$coverage))
tempSubset <- subset(tempSubset, subset = !duplicated(tempSubset[c("coverage")]),select = c("chrom", "start", "stop","coverage","strand"))
OMF$HighestPeak[peakFrameCoord] <- tempSubset$start[1]
OMF$HighestPeakReadCoverage[peakFrameCoord] <-tempSubset$coverage[1]
OMF$LowestPeakCoord[peakFrameCoord] <- min(tempPeakHold$start)
OMF$HighestPeakCoord[peakFrameCoord] <- max(tempPeakHold$start)
peakFrameCoord <- peakFrameCoord + 1
OMF[peakFrameCoord,] <- NA
tempPeakHold <- as.data.frame(matrix(nrow = 0, ncol = ncol(outputFrame)))
colnames(tempPeakHold) <- colnames(outputFrame)
}
#If the final outputFrame position is on its own
else if(!(outputFrame$start[x] - outputFrame$start[x-1]) <= adjacentPeakDistance){
OMF[peakFrameCoord,] <- c(outputFrame$chrom[1], outputFrame$strand[x], outputFrame$start[x], outputFrame$coverage[x], outputFrame$start[x], outputFrame$start[x])
}
}
#This handles the event that X+1$start is not part of the same peak
else {
tempPeakHold <- rbind(tempPeakHold,outputFrame[x,])
OMF$chrom[peakFrameCoord] <- outputFrame$chrom[1]
OMF$strand[peakFrameCoord] <- outputFrame$strand[1]
tempSubset <- subset(tempPeakHold, "coverage" == max(tempPeakHold$coverage))
tempSubset <- subset(tempSubset, subset = !duplicated(tempSubset[c("coverage")]),select = c("chrom", "start", "stop","coverage","strand"))
OMF$HighestPeak[peakFrameCoord] <- tempSubset$start[1]
OMF$HighestPeakReadCoverage[peakFrameCoord] <-tempSubset$coverage[1]
OMF$LowestPeakCoord[peakFrameCoord] <- min(tempPeakHold$start)
OMF$HighestPeakCoord[peakFrameCoord] <- max(tempPeakHold$start)
peakFrameCoord <- peakFrameCoord + 1
OMF[peakFrameCoord,] <- NA
tempPeakHold <- as.data.frame(matrix(nrow = 0, ncol = ncol(outputFrame)))
colnames(tempPeakHold) <- colnames(outputFrame)
}
}
#Remove any NA's that pop up
OMF_Comp <- OMF[complete.cases(OMF),]
rownames(OMF_Comp) <- 1:nrow(OMF_Comp)
OMF_Comp$LowestPeakCoord <- as.numeric(OMF_Comp$LowestPeakCoord)
OMF_Comp$HighestPeakCoord <- as.numeric(OMF_Comp$HighestPeakCoord)
OMF_Comp$HighestPeakReadCoverage <- as.numeric(OMF_Comp$HighestPeakReadCoverage)
OMF_Comp$HighestPeak <- as.numeric(OMF_Comp$HighestPeak)
return(OMF_Comp)
}
#' @importFrom dplyr arrange distinct
#' @importFrom stats aggregate ppois complete.cases
#' @importFrom utils write.csv write.table read.table read.delim
#' @param CompInitialCondense Uses the output of CompStrand_InitialCondense as the input
#' @param peakCondensingDistance peakCondensingDistance Following the initial peak condensing step, this parameter is used to identify peak structures in the data that are close enough to be considered part of the same termination signal. In testing, we have not identified cases in which two distinct termination signals so proximal that the default parameters incorrectly combine the signals together.
#' @param OutputFileName A string that will be used to identify printed results files. When run with PIPETS_FullRun, this string will be input by the user in the beginning
#' @return The method writes a csv file in the project directory that contains the results for the Complement Strand termination peaks
#' @export
#'
#'
CompStrand_SecondaryCondense <- function(CompInitialCondense,
peakCondensingDistance = 20,
OutputFileName){
OMF_Comp <- CompInitialCondense
TWH <- as.data.frame(matrix(nrow = 0, ncol = ncol(OMF_Comp)))
colnames(TWH) <- colnames(OMF_Comp)
#This data frame is the output of the file. It contains the merged output of the significant peaks. More explanation above and eventually below
SWR_Comp <- as.data.frame(matrix(nrow = 1, ncol = 6))
colnames(SWR_Comp) <- c("chrom","strand","HighestPeak","HighestPeakReadCoverage","LowestPeakCoord","HighestPeakCoord")
#Parameters for the merging for loop below
x <- 1
PFC <- 1
#This loop mimics the prior condensing loop, but instead of condensing consecutive significant positions, it condenses proximal peaks.
#If two peaks are within a user defined distance of each other, this peak condenses that signal into one peak.
#The idea is that very proximal individual peak signals are likely not two distinct termination signals, but are more likely biological/technical noise
for(x in seq_along(OMF_Comp[,1])){
tempSubset <- ""
#This is the basic condition
if(x < nrow(OMF_Comp) & (OMF_Comp$LowestPeakCoord[x+1] - OMF_Comp$HighestPeakCoord[x]) <= peakCondensingDistance ){
TWH <- rbind(TWH,OMF_Comp[x,])
}
#This else if statement specifically handles the final position of the WindowTest_TopStrandPeaks. If functions as mentioned above, it is just specially designed for this set
else if(x == nrow(OMF_Comp)){
#If the final WindowTest_TopStrandPeaks position is part of the same peak as the previous position
if((OMF_Comp$LowestPeakCoord[x] - OMF_Comp$HighestPeakCoord[(x-1)]) <= peakCondensingDistance) {
TWH <- rbind(TWH,OMF_Comp[x,])
SWR_Comp$chrom[PFC] <- OMF_Comp$chrom[1]
SWR_Comp$strand[PFC] <- OMF_Comp$strand[1]
tempSubset <- subset(TWH, "HighestPeakReadCoverage" == max(TWH$HighestPeakReadCoverage))
tempSubset <- subset(tempSubset, subset = !duplicated(tempSubset[c("HighestPeakReadCoverage")]),select = c("chrom","strand","HighestPeak","HighestPeakReadCoverage","LowestPeakCoord","HighestPeakCoord"))
SWR_Comp$HighestPeak[PFC] <- tempSubset$HighestPeak[1]
SWR_Comp$HighestPeakReadCoverage[PFC] <-tempSubset$HighestPeakReadCoverage[1]
SWR_Comp$LowestPeakCoord[PFC] <- min(TWH$LowestPeakCoord)
SWR_Comp$HighestPeakCoord[PFC] <- max(TWH$HighestPeakCoord)
PFC <- PFC + 1
SWR_Comp[PFC,] <- NA
TWH <- as.data.frame(matrix(nrow = 0, ncol = ncol(OMF_Comp)))
colnames(TWH) <- colnames(OMF_Comp)
}
#If the final WindowTest_TopStrandPeaks position is on its own
else if(!(OMF_Comp$LowestPeakCoord[x] - OMF_Comp$HighestPeakCoord[x-1]) <= peakCondensingDistance){
SWR_Comp[PFC,] <- c(OMF_Comp$chrom[1], OMF_Comp$strand[x], OMF_Comp$HighestPeak[x], OMF_Comp$HighestPeakReadCoverage[x], OMF_Comp$HighestPeak[x], OMF_Comp$HighestPeak[x])
}
}
#This handles the event that X+1$stop is not part of the same merged peak. X is added to tempPeakFrame and tempPeakFrame is used to add one large merged peak to slidingWindowResults
else {
TWH <- rbind(TWH,OMF_Comp[x,])
SWR_Comp$chrom[PFC] <- OMF_Comp$chrom[1]
SWR_Comp$strand[PFC] <- OMF_Comp$strand[1]
tempSubset <- subset(TWH, "HighestPeakReadCoverage" == max(TWH$HighestPeakReadCoverage))
tempSubset <- subset(tempSubset, subset = !duplicated(tempSubset[c("HighestPeakReadCoverage")]),select = c("chrom","strand","HighestPeak","HighestPeakReadCoverage","LowestPeakCoord","HighestPeakCoord"))
SWR_Comp$HighestPeak[PFC] <- tempSubset$HighestPeak[1]
SWR_Comp$HighestPeakReadCoverage[PFC] <-tempSubset$HighestPeakReadCoverage[1]
SWR_Comp$LowestPeakCoord[PFC] <- min(TWH$LowestPeakCoord)
SWR_Comp$HighestPeakCoord[PFC] <- max(TWH$HighestPeakCoord)
PFC <- PFC + 1
SWR_Comp[PFC,] <- NA
TWH <- as.data.frame(matrix(nrow = 0, ncol = ncol(OMF_Comp)))
colnames(TWH) <- colnames(OMF_Comp)
}
}
SWR_Comp <- SWR_Comp[complete.cases(SWR_Comp),]
write.csv(SWR_Comp, file = paste(as.character(OutputFileName),"CompStrandResults.csv", sep = "_"),  row.names = FALSE)
}
#' @param slidingWindowMovementDistance This parameter sets the distance that the sliding window will be moved. By default, it is set to move by half of the sliding window size in order to ensure that almost every position in the data is tested twice.
#' @param adjacentPeakDistance During the peak condensing step, this parameter is used to define “adjacent” for significant genomic positions. This is used to identify initial peak structures in the data. By default this value is set to 2 to ensure that single instances of loss of signal are not sufficient to prevent otherwise contiguous peak signatures from being combined.
#' @param peakCondensingDistance Following the initial peak condensing step, this parameter is used to identify peak structures in the data that are close enough to be considered part of the same termination signal. In testing, we have not identified cases in which two distinct termination signals so proximal that the default parameters incorrectly combine the signals together.
#' @param threshAdjust This parameter is used to establish a global cutoff threshold informed by the data. PIPETS sorts the genomic positions of each strand from highest to lowest, and starts with the highest read coverage position and subtracts that value from the total read coverage for that strand. By default, this continues until 75% of the total read coverage has been accounted for. Increasing the percentage (e.x. 0.9) will lower the strictness of the cutoff, thus increasing the total number of significant results.
#' @param pValue Choose the minimum pValue that the Poisson distribution test must pass in order to be considered significant
#' @param topEndPercentage This parameter is used along with threshAdjust to trim off the influence exerted by high read coverage outliers. By default, it removes the top 0.01 percent of the highest read coverage positions from the calculation of the global threshold (e.x. if there are 200 positions that make up 75% of the total reads, then this parameter will take the top 2 read coverage positions and remove them from the calculation of the global threshold). This parameter can be tuned to account for datasets with outliers that would otherwise severely skew the global threshold.
#'
#' @return PIPETS outputs strand specific results files as well as strand specific bed files to the directory that the R project is in.
#' @export
#'
PIPETS_FullRun <- function(inputBedFile,readLength,slidingWindowSize = 25,
slidingWindowMovementDistance = 25,threshAdjust = 0.75,
pValue = 0.005,topEndPercentage= 0.01,
adjacentPeakDistance = 2, peakCondensingDistance = 20){
AllReads <- Bed_Split(inputBedFile, readLength)
message("+-----------------------------------+")
message("Performing Top Strand Analysis")
TopInititalPoisson <- TopStrand_InitialPoisson(
MinusStrandReads <- AllReads[[3]],
slidingWindowSize = slidingWindowSize,
slidingWindowMovementDistance = slidingWindowMovementDistance,
threshAdjust = threshAdjust, pValue = pValue,
topEndPercentage= topEndPercentage)
TopInititalCondense <- TopStrand_InitialCondense(
TopInititalPoisson = TopInititalPoisson,
adjacentPeakDistance = adjacentPeakDistance)
TopStrand_SecondaryCondense(
TopInititalCondense = TopInititalCondense,
peakCondensingDistance = peakCondensingDistance,
OutputFileName = AllReads[[1]])
message("+-----------------------------------+")
message("Performing Complement Strand Analysis")
CompInitialPoisson <- CompStrand_InitialPoisson(
PlusStrandReads = AllReads[[2]],
slidingWindowSize = slidingWindowSize,
slidingWindowMovementDistance = slidingWindowMovementDistance,
threshAdjust = threshAdjust, pValue = pValue,
topEndPercentage= topEndPercentage)
CompInitialCondense <- CompStrand_InitialCondense(
CompInitialPoisson = CompInitialPoisson,
adjacentPeakDistance = adjacentPeakDistance)
CompStrand_SecondaryCondense(
CompInitialCondense = CompInitialCondense,
peakCondensingDistance = peakCondensingDistance,
OutputFileName = AllReads[[1]])
}
PIPETS_FullRun("~/Desktop/PIPETS/316-TermSeqND0min.bed", 58)
document()
document()
load_all()
document()
load_all()
PIPETS_FullRun("~/Desktop/PIPETS/316-TermSeqND0min.bed", 58)
document()
load_all()
PIPETS_FullRun("~/Desktop/PIPETS/316-TermSeqND0min.bed", 58)
check()
document()
load_all()
check()
document()
load_all()
check()
install()
use_testthat()
library(BiocCheck)
BiocCheck()
seq_along(c(1,2,3))
seq_along(c(1,2,4))
seq_along(vector(length = 10))
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58)
BiocCheck()
BiocCheck()
BiocCheck()
BiocCheck()
BiocCheck()
?order
document()
load_all()
check()
BiocCheck()
document()
load_all()
BiocCheck()
document()
BiocCheck()
?subset
document()
load_all()
check()
document()
load_all()
check()
document()
load_all()
check()
BiocCheck()
document()
document()
load_all()
check()
document()
load_all()
check()
BiocCheck()
document()
load_all()
check()
BiocCheck()
document()
load_all()
BiocCheck()
document()
load_all()
BiocCheck()
usethis::use_vignette("vignettes")
usethis::use_vignette("PIPETS")
?break
break()
break
document()
load_all()
check()
document()
load_all()
check()
document()
load_all()
check()
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58, slidingWindowSize = 0)
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58, slidingWindowSize = 0)
document()
load_all()
check()
?file_test
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58, slidingWindowSize = 0)
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58, slidingWindowSize = 0)
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58, slidingWindowSize = 0)
?return()
document()
load_all()
check()
PIPETS_FullRun("316-TermSeqND0min.bed", readLength = 58, slidingWindowSize = 0)
BiocCheck()
?use_gpl_license()
use_gpl_license(version = 3, include_future = TRUE)
BiocCheck()
use_gpl_license()
document()
load_all()
BiocCheck()
BiocCheck()
BiocCheck::BiocCheck('new-package'=TRUE)
if (!requireNamespace("BiocManager", quietly=TRUE))
install.packages("BiocManager")
BiocManager::install(version = "devel")
